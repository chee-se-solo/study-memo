# Docker 覚書

いろいろと設定項目があったりドライバを自分で作ってカスタマイズしたりできるが、ここでは個人的によく使うものをまとめる。

## Dockerfile

基本。Docker Hub からイメージを持ってきてコマンドを実行したりファイルをコピーして配置したりする。

## docker-compose.yml

複数の Docker コンテナを連結させて稼働させるときに使う便利な設定ファイル。
コンテナ同士の依存関係やホストに開放するポート、ボリュームのマウントなどコンテナの外との関係を設定として記述できる。  
Docker コンテナは１つにつき 1 プロセスが基本なので、APP コンテナ、DB コンテナに別れたり、さらに WEB コンテナが追加されたりとプロジェクト内でコンテナが増えていくのだが、それらをまとめて一コマンドで管理できるようにする便利なやつ。  
また、Dockerfile に記述できないコマンドオプションも記述できるので、１つのコンテナだけでも起動時のオプションを省略する用途で便利。コンテナの名づけとか、ホストとのマウント設定とか、定数（引数）とか一々打ち込む手間が省けるのはうれしい。

## Dockerfile 基本コマンド

### FROM

Docker イメージの指定。複数のイメージを指定して一つのコンテナを作成するマルチステージビルドというものもある。後述。

### RUN

コマンドの実行。Docker は実行結果をキャッシュするのと、Dockerfile の命令の数だけレイヤーを作って状態を管理しているので
RUN で実行するコマンドはできるだけ && で結んで一回で済むように作る。

### WORKDIR

作業ディレクトリ指定。シェルでいうところの cd コマンド。
これの後に相対パスを記述した場合、ここで指定したディレクトリからのパスになる。

### COPY

ファイルのコピー。コンテナ―コンテナ間やホスト－コンテナ間でもファイルの受け渡しができるのが、RUN cp との違い。コピーするファイルの変更を検知してレイヤーキャッシュし直してくれるので、RUN cp よりもこっちが推奨される。マルチステージビルドでも重要なコマンド。

### ADD

なんかいろいろできるらしい。詳しく調べていない。
COPY コマンドと同じことができる上にいろいろと機能が足されている上位互換コマンド。何をしているのかわかりにくいので、COPY コマンドで足りるときは COPY コマンドで済ませることが推奨される。

### EXPOSE

コンテナ内で Listen するポートの指定。Docker サンドボックス内で Listen するだけで、このポートをホストに公開するわけではない。ホスト側に公開するにはコンテナ作成時に`docker`コマンドで指定するか docker-compose.yml に記述する。
例えば、ホストの 63306 番ポートとコンテナの 3306 番ポートをつなげると、ホストの 63306 番ポートにアクセスすることでコンテナの MySQL データベースにアクセスしたりできる。

### ENV

環境変数の設定。複数の環境変数を一つの ENV で指定することもできる。定数の宣言のように使っている記事もあるが、このコマンドで設定した値がコンテナの環境変数になるので注意。ただの定数なら ARG を使おう。

### CMD

コマンド・・・のように見せかけてデフォルト引数の設定。詳しくは後述。

### ENTRYPOINT

Docker コンテナを立ち上げたときの実行プロセス。entrypoint.sh などのシェルを指定することで特定処理を実行させつつ、CMD や入力のコマンドを実行させることもできる。詳しくは後述。

## docker-compose.yml 基本設定

これを見れば大体わかる。

- <https://qiita.com/zembutsu/items/9e9d80e05e36e882caaa>
- <https://docs.docker.com/compose/compose-file/>

### version

Docker Engine と対応した docker-compose ファイルのバージョン。今なら 3 を指定しておけば間違いない。

### services

docker-compose で管理するコンテナ。

### services - (サービス名)

コンテナ名とは別につけるコンテナの名前。docker コマンドはコンテナ名を指定して使うが、docker-compose コマンドはサービス名を指定して使う。

### services - (サービス名) - image

コンテナのベースイメージ。Dockerfile でいうところの FROM

### services - (サービス名) - build

Dockerfile へのパスを指定する。その Dockerfile を使ってイメージをビルドする。
Dockerfile の名前を指定する場合は build でははく、以下の context と dockerfile を使って指定する。

### services - (サービス名) - build - dockerfile

Dockerfile 名の指定。Dockerfile 以外の名前を使いたいとき。

### services - (サービス名) - build - context

Docker ファイル内での context 指定。さっくり説明すると、Dockerfile 内でのホスト側のカレントディレクトリ指定。指定しないと Dockerfile が配置されているディレクトリになる。Dockerfile を docker-compose.yml より下のディレクトリに入れているときなどに役に立つ。

### services - (サービス名) - build - args

context が指定されているときのみ使用可能。Dockerfile の ARG に値を注入する。Dockerfile 内で値が定義されている場合は上書きする。

### services - (サービス名) - build - target

マルチステージビルドのターゲット指定。マルチステージビルドは後述。

### services - (サービス名) - container_name

コンテナ名をつける。指定がない場合はサービス名から自動的につける。

### services - (サービス名) - environment

環境変数設定。Dockerfile でいうところの ENV。シェルの環境変数をコンテナに送る。上書きすることもできる。env_file で定義した環境変数も上書きする。

### services- (サービス名) - env_file

環境変数設定。environment の記述を別ファイルに切り出したもの。environment 同様にシェル環境変数を送ることも、値の上書きもできるが、environment の値で上書きされる。

### services - (サービス名) - ports

ポート指定。Dockerfile でいうところの EXPOSE に近い。63306:3306 とかでホストのポート(63306)とコンテナ内で Listen するポート(3306)の組み合わせを指定できる。

### services - (サービス名) - expose

Dockerfile の EXPOSE と同じ。サンドボックス内でのみポートが開いていればいいなどの特別な理由がない限りは ports を使うと思う。

### services - (サービス名) - depends_on

依存サービス名の指定。APP コンテナの場合、DB コンテナに依存しているのでこれを指定する。

### services - (サービス名) - volumes

マウントするボリュームを指定できる。.:/path/to/などの指定で、docker-compose.yml があるフォルダがコンテナ内の/path/to にマウントされる。 **大量のファイルやサブディレクトリをそのままマウントするとすさまじいパフォーマンスの劣化を招くので、後述のチューニングを検討すること。** vendor/bundle や node_modules をそのままマウントしてはいけない。  
また、＜ボリューム名＞:/path/to などで、ルート階層の volumes で定義したボリュームをマウントすることもできる。volumes で定義した ボリューム は複数のサービスコンテナで共有することもできる。
コンテナを削除しても volumes で定義したボリュームは消えない。

### services - (サービス名) - volumes_form

指定したコンテナにマウントされているボリュームをすべて自コンテナにもマウントする。ボリュームがたくさんあるときは、一つのコンテナに全ボリュームをマウントして（[データ・ボリューム・コンテナ](https://docs.docker.jp/engine/userguide/dockervolumes.html#id8)）ほかのコンテナからは volumes_from でそのコンテナ一つを指定する、一種のボリュームグルーピングテクニックがある。

### services - (サービス名) - stdin_oepn

端末（tty）からの入力を受け付ける。コマンドの -i オプションに相当。

### services - (サービス名) - tty

端末を受け付けるというかなんというか。ssh でおなじみのアレ。コマンドの -t 相当する。
Docker コンテナはポートを Listen するプロセスが生きているか、このオプションが true でないと起動後にすぐ終了してしまうので注意。

### services - (サービス名) - entrypoint

Dockerfile でいう ENTRYPOINT。

### services - (サービス名) - command

Dockerfile でいう CMD。

### volumes

データを永続化するボリュームを定義する。

### volumes - (ボリューム名)

ボリュームの名前を定義する。名前がないボリュームはマウントしているコンテナが削除された時などにひっそりと削除されることもあるので、大事なデータは名前付きボリュームにしておくかホストのディレクトリにマウントするのがいい。

### volumes - (ボリューム名) - driver

ボリュームドライバの指定。デフォルトは local。それ以外の指定は見たことがないがネットワークドライブとか指定できるんだと思う。

### networks

Docker コンテナ同士でネットワークを構築する。いろいろできそうだが調べていない。Docker を本番投入するなら必要になりそう。開発環境では必要ないと思う。

## ENTRYPOINT と CMD

Docker コンテナで実行するプロセス指定と追加引数の関係。
ここを読めばわかる。
<https://qiita.com/uehaj/items/e6dd013e28593c26372d>

ENTRYPOINT が docker run するときのプロセスで、CMD が追加で指定できる引数。  
乱暴に説明すれば、ENTRYPOINT がコマンドで CDM が追加引数。ただし、ENTRYPOINT がないときは CMD にコマンドを設定できる。  
要は `docker run` した際に、`[ENTRYPOINT][cmd]` の形で実行されると思っていてもいい。  
ENTRYPOINT と CMD の設定の仕方次第で当てはまらない挙動も普通にあるが、細かい挙動はあまり統一性がない。  
詳細はこっち。  
<http://docs.docker.jp/v17.06/engine/reference/builder.html#cmd-entrypoint>

ENTRYPOINT にシェルスクリプトファイルを指定して、`exec "$@"`の形で終わらせることで、ENTRYPOINT で特定の処理をさせつつ、最後に CMD のコマンドを実行する、という挙動もできる。
具体的には entrypoint.sh 内で、pid ファイルなどの動作に関わるファイルを削除し、CMD でサーバーを起動するなど。

## Docker の環境変数の設定

地味にややこしくて困ったので整理しておく。  
ネットで調べてるとイメージに環境変数を封入とか何とか見つかるが、そんなことしてない。それをするのはおそらく Dockerfile の ENV だけ。`docker-compose build`で作ったイメージを`docker run`で覗いてみたが docker-compose.yml の環境変数は何もなかった。  
**原則として環境変数はコンテナ作成時に決まる。**`docker-compose` でコンテナを作成すると、docker-compose.yml の設定をコンテナ作成時にセットしてくれるだけのようだ。

- イメージに環境変数を封入するのは Dockerfile 内の ENV のみ。他にはないし、それもコンテナ作成時に上書きできる。
- 基本的にシェルの環境変数は、コンテナに渡されない。渡したい場合は、`environment`、`env_file`で環境変数名を列挙しておく。
- `environment`、`env_file`では、渡す環境変数の指定だけでなく値の設定もできる。また、Dockerfile 内の`ENV`でも環境変数を設定できる。重複した場合にどれが優先されるかは以下の通り。

### 環境変数の設定強度

```plain text
envrionment(docker-compose.yml) > env_file(docker-compse.yml) > ENV(Dockerfile) > シェル環境変数
```

上記の順でコンテナに設定される。左にあるほうが優先。つまり環境変数名が衝突した場合は左が適用される。これは `docker-compose` を使った場合だが、`docker` を使った場合、yml の代わりにオプションの指定が対応すると思われる。

> まさかとは思うけど、environment と env_file の強弱関係は`docker`コマンドのオプションの指定順とか yml ファイル内の設定順とかじゃあるまいな。さすがにそこまで検証してないぞ。

### Dockerfile 内で有効な環境変数

環境変数はコンテナ作成時に決まる。Dockerfile はイメージをビルドするときに使う。では、Dockerfile 内ではシェル環境変数や environment の指定は無効なのか。
調べてみたところ無効だった。シェル環境変数ならば docker-compose.yml 内で環境変数を展開して args を通すことで Dockerfile 内に注入できたが、environment や env_file の設定値はどうやっても Dockerfile に注入できないようだ。

## ボリュームがマウントされるタイミングとマウントオプションによるチューニング

ボリュームがマウントされるのはコンテナ作成時。Dockerfile はビルド時に読み込まれる。つまり、Dockerfile 内ではボリュームをマウントして中のファイルを参照することができない。Dockerfile 内で`bundle isntall`や`yarn install`すると、ボリュームやホスト側に永続化しておいたパッケージ群を参照できず再度フルインストールすることになる。  
これを回避するために、マウント後にインストールする必要がある。タイミングは以下の通り。

### マウントのタイミング

```plain text
ビルド（Dockerfile） -> マウント -> entrypoint（command）
```

つまり、entrypoint か command でシェルスクリプトを実行し、その中でインストールすればよい。ビルドが終わった後、entrypoint や command のタイミングではマウントは完了しているので前回のインストール結果をキャッシュとして使うことができる。

これで時間は節約できるようになるが、実は一長一短ある。

- **vendor/bundle や node_modules を名前付きボリュームに永続化した場合。**

  - :x: Dockerfile 内でのインストールをあきらめて、entrypoint でインストールすることになる。ビルド用ツール群（make や gcc など）をコンテナ内に含める必要があるのでイメージが大きくなる。
  - :x: entrypoint.sh が必要になるのでコンテナの作りが Dockerfile だけからではわからなくなる。Dockerfile が少し複雑になる。
  - :x: ホスト側にファイルが残らないので IDE の補完がきかなくなるかもしれない。
  - ✔️ 前回のインストール結果をキャッシュとして高速化できる。

- **vendor/bundle や node_modules をホストのディレクトリからマウントした場合。**

  - :x: ボリューム化と同じデメリットがある。つまり、イメージサイズが大きくなり、Dockerfile が複雑になり、entrypoint.sh が必要になる。
  - :x: ホストとの間に大量の IO が発生するので後述のチューニングをしないと激烈に遅くなってコンテナが使い物にならなくなる。
  - ✔️ ホスト側にパッケージの内容が残るので、IDE の補完の心配はない。
  - ✔️ 正しくチューニングすれば高速化を期待できる。

- **パッケージインストール済みのイメージを自作しておきマルチステージビルドでコピーしてくる。**

  - :x: 下準備としてあらかじめインストールしたイメージを作成しておく必要がある。
  - :x: 自作イメージを使うので Dockerfile から全ての処理内容を把握できなくなる。
  - ✔️ ビルドツールが不要になるのでイメージが小さくなる
  - ✔️ インストール自体しないので高速化する
  - ✔️ ~~すべてインストールしたイメージが一つあればすべてのプロジェクトで使いまわすことができる。~~
    - :x: なかなかよいと思ったが、node_modules をマルチステージ継承し続けるといつか秘伝のたれのような熟成をしそうだし、別プロジェクトから使いまわすだけならホストにマウントする方法でもできるし、node のバージョン違いが怖い。そもそも別プロジェクトで作った node_modules などをコピペで持ってくるのは褒められたやり方ではないのでは？
  - ✔️ 複数のプロジェクトで使いまわすことさえしなければ最小のイメージを最速でビルドできるのかもしれない。ただし事前に自作イメージを用意する必要があるので時短にはならないし、むしろ手間がかかる。

- **あきらめて Dockerfile 内でフルインストールした場合。**

  - :x: ビルドのたびにインストール時間がかかる。
  - :x: 上記に加えて、Gemfile や package.json の変更のたびにリビルドが必要になる。
  - ✔️ Dockerfile 内で使い終わったビルドツールを即座に捨ててレイヤーキャッシュの肥大化を最小限にとどめることができる。極限まで小さくしたい本番用イメージの作成なら結局これなのかもしれない。

結論としては名前付きボリュームに保存するのが一番確実に高速化できそうそうだ。IDE の補完がうまく動ないなら、下記のチューニングを前提としてホストディレクトリにマウントするのがよい。（補完は IDE の設定や拡張でどうにかなりそうな気もする）

### ホストのディレクトリをマウントする際のチューニング

これを読めばわかる。  
<https://docs.docker.jp/docker-for-mac/osxfs-caching.html>

デフォルトの consistent がいつ必要になるのか正直よくわからない。Docker を載せているホストもサーバーで Docker 内サーバーとやり取りをしている場合とかに何か必要になるのかもしれない。  
開発環境では基本的にプロジェクトフォルダを cached にして、node_modules などのコンテナ内から読み書きするだけのディレクトリを delegated にすれば最大限高速化できそうだ。

## マルチステージビルド

ここを読めばわかる。  
<https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/multistage-build/>

二種類の使い方があり、別のイメージから成果物だけぶっこ抜いてくるやり方と、ステージを３つ以上に分けて継承のようにイメージを分岐させる使い方がある。  
ぶっこ抜いてくるほうは、FROM を複数書いて、ビルドし終わったバイナリだけ頂戴したり、Dockerhub の公式イメージから目的のものだけ COPY したりする。  
継承のほうは開発用イメージと本番用イメージの共通部分を base として抽出して、複数のイメージのうち target 指定したほうだけ使う。

```dockerfile
FROM iamge as base

...any core steps

FROM base as dev

...any steps for dev

FROM base as prod

...any steps for prod

```

ぶっこ抜くやり方はレイヤー数削減に効果があり、継承のほうはコンテナの設定を一ファイルに簡潔にまとめることができる。
