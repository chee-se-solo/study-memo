# リーダブルコード 覚書

せっかく読み直したので、まとめだけでもまとめておく

## 1 章 - 理解しやすいコード

- **コードはほかの人が最短時間で理解できるように書かなくてはならない**

## 1 部 - 表面上の改善

### 2 章 - 名前に情報を詰め込む

- **明確な単語を選ぶ**  
  Get ではなく、状況に応じて Fetch や Download を使う

- **tmp や retval などの汎用的な名前は避ける**  
  ただし、明確な理由がある場合は別だ。

  > 事実として一時的で短命な変数に tmp とつけるのは妥当。スコープが小さい変数なら短い命名でもよい。

- **具体的な名前を使って、物事を詳細に説明する。**  
  ServerCanStart() より CanListenOnPort() の方が明確だ。

  > DISALLOW_EVIL_CONSTRUCTOR という名前は抽象的すぎる。

- **変数名に大事な情報を追加する**
  ミリ秒を表す変数名には、後ろに \_ms を付ける。これからエスケープが必要な場合には、前に raw\_ をつける。

  > raw_password など。全部につけるというよりは、変数の意味を間違えたらバグになりそうなところ、セキュリティにかかわる部分など。

- **スコープの大きな変数には長い名前を付ける**  
  スコープが数画面に及ぶ変数に１～２文字の短い暗号めいた名前をつけてはいけない。短い名前はスコープが数行の変数に着けるべきだ

- **大文字やアンダースコアなどに意味を含める。**  
  例えば、クラスのメンバ変数にアンダースコアを付けて、ローカル変数と区別する。

### 3 章 - 誤解されない名前

- **あいまいな単語を使わない**

  - 例えば、文字列における length はあいまいな単語に当たる。文字数、単語数、バイト数など。適切な名前は chars、bytes などが考えられる。
  - filter もあいまいな単語に当たる。select、exclude など使うとわかりやすい。
  - 限界値に limit を使うのもその値を含むかどうかであいまいになる。限界値は min-max （含む）、範囲は、first-last （含む）、begin-end （含まない）を使おう。

- **ブール値の名づけに規則を作る**  
  真偽値は is や has などを使う。否定形は避ける。

- **ユーザーの期待に注意する**  
  get() や size() は軽量な処理であることが期待される。（C++では O(1)であることが定められている）

### 4 章 - 美しさ

- 複数のコードブロックで同じようなことをしていたら、シルエットも同じようなものにする。

- コードの「列」を整列すれば、概要が把握しやすくなる。

- ある場所で A・B・C のように並んでいたものを、他の場所で B・A・C のように並べてはいけない。意味のある順番を選んで、常にその順番を守る。

- 空行を使って大きなブロックを論理的な「段落」に分ける。
  > 段落ごとに内容を要約したコメントを書くのもいい

### 5 章 - コメントすべきことを知る

- **コメントすべきではないこと**

  - コードからすぐに抽出できること。

  - ひどいコード（例えば、ひどい名前の関数）を補う「補助的なコメント」。コメントを書くのではなくコードを修正する。

- **記録すべき自分の考え**

  - なぜコードがほかのやり方ではなくこうなっているのか（「監督のコメンタリー）」

  - コードの欠陥を **TODO:** や **XXX:** などの記法を使って示す。

  - 定数の値にまつわる「背景」。
    > マジックナンバーの理由、説明とか

- **読み手の立場になって考える**

  - コードを読んだ人が「えっ？」と思うところを予想してコメントをつける。

  - 平均的な読み手が驚くような動作は文書化しておく。

  - ファイルやクラスには「全体像」のコメントを書く。

  - 読み手が細部にとらわれないように、コードブロックにコメントをつけて概要をまとめる。

### 6 章 - コメントは正確で簡潔に

- **複数のものを指す可能性がある「それ」や「これ」などの代名詞を避ける。**  
  あるいは文章を組み替えて、「それ」が明確にただ一つを指すように書く。

- **関数の動作はできるだけ正確に説明する**

  - 行数をカウントする → `\n` をカウントする。
  - コメントで入出力などの実例をつける。
    > 単純すぎる例を使わず、エッジケースやコーナーケースを使って、「この場合はどうなる？」といったこまい疑問が出にくいようにする。  
    > また、入力と出力の関係性を勘違いさせうる例を避けてスマートに例示する。  
    > 配列を分割する関数で、返り値が「１」になる例では、引数の要素から「１」を避ける、など。

- **コードの意図は、詳細レベルではなく、高レベルで記述する**

  - 配列を逆順に走査する → 値段の降順に走査する、など。冗長検査にもなってバグの混入防止になる。

- **よくわからない引数にはインラインコメントを使う**  
  `connect(/* timeout_ms = */ 10, /* use_encryption = */ false);`

  > 正直いって読みにくいと思う。

- **多くの意味が詰め込まれた言葉や表現を使って、コメントを簡潔に保つ**  
  キャッシュ、正規化など、よく知られた言葉を使って簡潔に説明する。
  > 変数の命名における、あいまいな言葉を使わない、とは反対の方針に見える。

---

## 2 部 - ループとロジックの単純化

### 7 章 - 制御フローを読みやすくする

- **比較は左側に変化する値、右側により変化しない値を置く**  
  `if (num <= max_num)` をあえてひっくり返すことはない
- **if/else 分のブロックは適切に並び変える**  
  一般的には、肯定する条件（否定でない条件）、単純な条件、目立つ条件を先に処理する。
- **三項演算子、do/while、goto などはコードが読みにくくなることが多い。適切に扱い、代替があるなら使わないことを考える。**  
  簡潔に表現できるなら三項演算子の方が読みやすいことは多い。`do/while` は大抵の場合は `while` に置き換えられる。`goto` は C 以外ならば必ず回避できる。
- **ネストしているとコードを追うのに集中力が必要になる。深いコードを避けるには「直線的」なコードを選択する。**
  > ガード節が特に便利だ

### 8 章 - 巨大な指揮を分割する

- **説明変数を導入する**
  - 説明変数を使うことで巨大な式を分割できる。
  - 簡潔な名前で式を説明することで、コードを文書化できる。
  - コードの主要な「概念」を読み手が認識しやすくなる。
- **ド・モルガンの法則を使ってロジックを操作する。**
- **複雑な if 文は小さな if 文に分割する。**  
  `if` の条件が二行以上含まれていないのは理想的な状況といえる。  
  問題を否定してみたり、反対のことを考えてみたりすることが必要。

### 9 章 - 変数の読みやすさ

- **邪魔な変数を削除する。**  
  結果をすぐに使って、「中間結果」の変数を削除する。

  > 結果を頑張って中間変数に保持して関数の最後に`return`するのは bad practice。結果が確定した時点ですぐに`return`してしまえばいい。

- **変数のスコープをできるだけ小さくする**  
  変数を数行のコードからしか見えない位置に移動する。

  > javascript ならクロージャが便利だ。

- **一度だけ書き込む変数を使う**  
  変数に一度だけ値を設定すれば（イミュータブルにすれば）、コードが理解しやすくなる。

---

## 3 部 - コードの再構成

### 10 章 - 無関係の下位問題を抽出する

- **プロジェクト固有のコードから汎用コードを分離する**  
  一般的な問題を解決するライブラリやヘルパー関数を作っていけば、プログラムに固有の小さな核だけが残る。

  1. 関数やコードブロックを見て、「このコードの高レベルの目標は何か」を考える。
  2. コードの各行に対して「高レベルの目標に直接的に効果があるのか？無関係の下位問題を解決しているのか？」を考える。
  3. 無関係の下位問題を解決しているコードが相当量あれば、それらを抽出して別の関数にする。

  > 段落を関数に抽出したとき、行数のわりにシンプルな入出力になる場合は、そのコードはグルーコード（下位問題を解決するためのコード）かもしれない。

- **メソッド内部の処理は同じ抽象度のレベルになるようにする。**
  > コードのシルエットをそろえるように、抽象度の概観もそろえるとよい、ということかな

### 11 章 - 一度に一つのことを

- **一度に一つのことを行う**

  1. 読みにくいコードが行っているタスクを列挙する
  2. 別の関数、クラスに分割できるタスクを見つける
  3. それ以外のコードは、論理的な段落になる

  > 関心ごとがあちこちに移っているタスクをデフラグして一か所にまとめて段落化する。  
  > 要素 A、B、C に 1 → 2 → 3 という順で処理を書けたいとき
  > `A1→B1→A2→B2→C1→C2→A3→B3→C3` → `A1→B1→C1 → A2→B2→C2 → A3→B3→C3`
  >
  > または、1 → 2 → 3 をヘルパーメソッド化する。それぞれに微妙な違いがあって一つのヘルパーメソッドにまとめにくいなら、３つのヘルパーメソッドを作ってしまうのもありなようだ。  
  > `A123 → B123 → C123`  
  > DRY じゃないようにも見えるが、似ている処理のシルエットをそろえるとか、関数の抽象度をそろえるとかのポイントにもかなっているし、ヨシ！
  >
  > そもそも一つのメソッドにまとめにくいなら、関連があって論理的に似ている処理だとしても、物理的には違う処理なのかもしれない。

  どう分割するかより、分割することそのものが大切だ。

### 12 章- コードに思いを込める

- **プログラムを簡単な言葉で説明する**  
  説明で使っている単語やフレーズをよく見れば、分割する下位問題がどこにあるかがわかる。説明することでコードがより自然になっていく。ラバーダッキングとも呼ばれる。

  > 考慮もれが生まれないように慎重にケースを分析する必要はある。修正するブロックに単体テストが存在し、十分なテストケースが用意されているかどうかも重要。

- **ライブラリを知る**
  > グルーコードがライブラリが提供している関数一行になることはよくある。そのためのライブラリであり、ユーティリティなのだから。

### 13 章 - 短いコードを書く

冒険。興奮。ジェダイはそんなものは求めておらん。

- **不必要な機能をプロダクトから削除する。過剰な機能を持たせない。**
- **もっとも簡単に問題を解決できるような要求を考える。**
- **定期的にすべての API を読んで、標準ライブラリに慣れ親しんでおく。**

---

## 第 4 部 - 選抜テーマ

### 14 章 - テストと読みやすさ

- **テストのトップレベルはできるだけ簡潔にする。入出力のテストはコード 1 行で記述できるといい。**  
  ヘルパーメソッドを作って活用する。入力と出力が一目でわかるようにして、テストのための準備はヘルパーメソッドに可能な限り切り出す。
- **テストが失敗したらバグの発見や習性がしやすいようなエラーメッセージを表示する。**  
  自分で好みのエラーメッセージを出すアサーションを作るのがいい。
  > さすがにそれはめんどくさいと思う。適切なアサーションを使うだけでいい。
- **テストに有効なもっとも単純な入力値を使う。**
  要件を分割して一つずつ満たしているかテストする。
  > 複合した時のケースは検査しない？メンテナンス性を重視して 100% のバグを単体テストで見つける必要はないということか。
- **テスト関数に説明的な名前を付けて、何をテストしているのか明らかにする。Test1()ではなく、Test\_&lt;関数名>\_&lt;状況>のような名前にする。**

### 15 章 - 「分 / 時間カウンタ」を設計・実装する

- **ConveyorQueue**
  最大長のあるキュー。「シフト」可能で合計量を保持する。
- **TrailingBucketCounter**
  時間経過に伴って`ConveyorQueue`を移動する。また、１つの（最新の）時間帯のカウントを任意の制度で保持する。
- **MinuteHourCounter**
  2 つの`TrailingBucketCounter`を保持する。1 つは 1 分間のカウントで、もう 1 つは 1 時間のカウントだ。
  > 読みやすいコードになったところまでは自分でもできそうだが、そこで満足しそう。最後のより柔軟な設計にするところまで自分でやろうとするかは疑問、というかしない。独自のライブラリに追加できるレベルまでブラッシュアップするだけのスキルもない。設計力が弱いのか。
  >
  > `TrailingBucketCounter`の実装を読むところでやや詰まった。なぜ `current_bucket = time_t / sec_per_bucket`になるのか、というところで。読んだ人が「えっ？」となりそうなところには、それを予想してコメントを入れておいてほしかった。
  >
  > 最終的に番号飛びを許容してバケツに ID を振って管理しているのだと解釈した。最新のバケツの ID を基準に長さ n の ID 範囲ののバケツを集計すれば対象の時間帯の合計が取れるという作りなのかな。私は時間と値をセットで保持する以外の実装方法は出てこなかったよ。
  >
  > 書いていて気付いたが、これだと同時に二つのバケツを追加した場合、同じ time_t で二つのバケツが追加されないだろうか。同じ ID を持つバケツが二つになる。ID の個数=バケツの個数という実装なので、一つの ID を二つのバケツが持っているこの状態になると常にバケツの数が一個ずれたまま戻らず、`ConveyorQueue.clear()`が呼ばれない限りずバケツが一個多い結果を返す。  
  > サーバーの話だし、同時アクセスは当然ありうるケースだと思うんだけど。nginx みたいなシングルスレッドのサーバーを使う想定なのかな。
  >
  > と思ったけど`TrailingBucketCounter`は柔軟なクラスなので、1 バケツに 60 秒でも担当させることができる。1 つの ID に複数バケツを突っ込むことは簡単にできる。そもそもシングルスレッドサーバーでも 1 秒に 1 バケツじゃ絶対に対応しきれない。
  >
  > と思ったけど引数に`count`がある。そして転送バイト数の話である。ログファイルを監視して秒ごとに集計した値を`Counter`に送って`bucket`を作るとかならそんな考慮はいらない。サーバーの処理の話だけどサーバーに処理させるプログラムではなかったのか。プログラムに集中して前提要件を忘れるのも稀によくあるバグの原因だから気をつけないといけない。
