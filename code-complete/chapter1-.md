# Code Complete 2 版

## 第 1 章 ソフトウェアコンストラクションへようこそ

### 1.1 ソフトウェアコンストラクションとは

課題定義以外のほぼすべて。特にコーディングとデバッグを中心に基本設計、詳細設計、単体テスト、結合テスト。  
含まないのはプロジェクトマネジメント、要求開発、ソフトウェアアーキテクチャ（概略設計）、ユーザーインターフェイス設計、システムテスト、保守など。

> 価値を作るプログラミングというより、プログラムを作る設計とコーディングにフォーカスするっぽい。実際には要求に合わせた設計とか考えるものだろうけど。

### 1.2 なぜソフトウェアコンストラクションは重要か

- プロジェクトの時間の大部分（30~80%）を占める
- ソフトウェア開発の中心にある（設計はコンストラクションを円滑にするために行い、テストはコンストラクションを検証するために行う）
- 個々のプログラマの生産性に寄与する
- コンストラクションの成果物であるソースコードはソフトウェアを正確に記述した唯一のドキュメントである
- 開発において必ず実行される唯一のアクティビティである

## 第 2 章 ソフトウェア開発への理解を深めるメタファ

### 2.1 メタファの重要性

- メタファ（モデル化）は科学の進歩に大きく貢献してきた。ベンゼン環、気体の力学モデルなど。
- かつてはコンピュータを中心に、データがカードのように流れているととらえられていたが、今はデータベース中心、データの塊に注目するようになった。

### 2.2 ソフトウェアメタファの使用法

- ソフトウェアメタファは「アルゴリズム」というより「ヒューリスティック」である。
- アルゴリズムは命令を一つ一つ説明するが、ヒューリスティックは命令の探し方を教える。
- メタファを使ってプログラミング上の問題やプロセスを見極める。
  > モデル化して構造やフローをとらえるのは大事

### 2.3 一般的なソフトウェアメタファ

- 一般に言われるソフトウェアメタファはろくなものがない

#### 2.3.1 ソフトウェアの書法：コードを書く

- 手紙を書くというメタファは適切でない

#### 2.3.2 ソフトウェアの農場：システムを育てる

- 農場のメタファはふさわしくない

#### 2.3.3 ソフトウェアの真珠養殖：システムのアクリーション

- ソフトウェアの成長という表現に、ソフトウェアの「アクリーション」を意味する場合がある
- 外部から追加または取り込みを重ねて成長、規模を広げること。蓄積による真珠の成長。
- ソフトウェアシステムに少しずつ追加していく、インクリメンタルな設計、構築、テストは最も強力なソフトウェア開発概念の１つでもある。
- まず動作するモックを作り、一つ一つ実装して置き換えていく。
- 貝が真珠を育むメタファは拡大解釈が難しく、インクリメンタル型開発をイメージするのに良い。

#### 2.3.4 ソフトウェアコンストラクション：ソフトウェアを構築する

- 「構築する(build)」というイメージは、書く、育てるというイメージよりも適切
- 空き缶を 10 個重ねて塔を作るのと 1000 個重ねて塔を作るのでは空き缶を用意する以上に、計画や作業が全く異なる
- 既製品を採用したりオーダーメイドでコストをかけるように、プログラムも同じく説明できる。
- 建築も開発も共通して計画が大切である
- プロジェクトの規模によって効果的な開発手法が違うことも建築と同じ
- ソフトウェア開発の一般的な用語の多くは建築のメタファに由来する

#### 2.3.5 ソフトウェアテクニックの応用：知的道具箱

- 長い年月をかけて身に着けた数えきれないテクニック、トリック、魔法
- テクニックとは分析のツールであり、学べば学ぶほどそれを使うタイミングや正しく使う方法が詰まっていく。
- すべての手法、テクニック、ヒントを駆使するのに道具箱のメタファは役に立

#### 2.3.6 メタファの組み合わせ

- アクリケーションと建築を組み合わせてもいいし、書くメタファと組み合わせてはいけないわけではない
- ただし、ヒューリスティックな洞察から利益を導けるものでなくてはならい。メタファはあいまいなもの
- メタファも道具箱の強力な道具の一つ。

## 第 3 章 2 回測って、1 度で切るで切る：上流工程の必要性

### 3.1 準備の必要性

- 後期に品質向上を目指すならテストを強化する
- 途中ならコンストラクションのプラクティスを強化する
- コンストラクションにたどり着くころにはプロジェクト成功のカギを握る基礎作りがすでに済んでしまっているが、状況を確認し、計画を練り直すことはできる

#### 3.1.1 上流工程は現代のソフトウェアプロジェクトに必要か

- コンストラクションを本格的に開始する前に上流で適切な準備作業を行うとプロジェクトが最もうまく進行することがでーだで示されてい る
- 準備作業の最大の目標はリスクを減らすこと。早期にリスクを取り除き、スムーズにプロジェクトを進める。これの達成のために準備と計画に重きが置かれる
- リスクを軽減するためのアプローチはプロジェクトごとに違う

#### 3.1.2 準備不足の原因

- 一般的な原因は、上流の作業を端とする開発者が、十分な専門知識を持っていないこと
  - プロジェクトを計画する、業務分析を行う、包括的で正確な要求を行う、アーキテクチャを作成する。これらのスキルは並大抵のものではないが、ほとんどの開発者は訓練を受けていない。
- 2 番目の原因は、実践する能力があっても、コーディングに着手したいがために準備をおろそかにするため
- 3 番目は上司が設計に時間をかけるのをいやがるため

#### 3.1.3 コンストラクションの準備に有無を言わせない根拠

##### 論理的に訴える

- マネジメントの面から、計画とはプロジェクトの期間、人員、コンピュータの台数を決定すること
- 技術面から、計画とは間違ったものを作って予算を無駄に品用に、何を作るのか理解すること
- システムを構築する前に構築する方法について考えることも重要。コストをかけてから行き詰っていはいけない。

##### たとえで訴える

- ソフトウェアシステムを構築することは、人や金を必要とするほかのプロジェクトに似ている

##### データで訴える

- 事前に欠陥を取り除くことは、システムテストやリリース後に取り除くことに比べて 10~100 倍少ないことがわかっている。
- 一般的なソフトウェア開発サイクルの所要時間の 50% を、デバッグやそれに伴う手戻り作業に費やしている
- 早い段階で欠陥修正に着手することで開発コストやスケジュールを半分以下に軽減できる

##### 上司の適正テスト

次のうち、どれか

- デバッグ作業が多いことが予想されるため、すぐにコーディングを開始したほうが良い
- 欠陥はそれほど見つからないだろうから、テストに時間をかける予定はない
- 要求と設計は入念に調べたので、コーディングやデバッグで大きな問題にぶつかることはないだろう

### 3.2 ソフトウェアの種類の特定

- 業務システムのプロジェクトは反復型の手法から利益を得る傾向にある

- 医療システムはより逐次的な手法が求められる傾向にある。つまり、極めて高いレベルの信頼性を保証するには、要求が何呈していることが不可欠

#### 3.2.1 反復型手法への準備

- 反復型手法は上流の作業が不十分な場合の影響を緩和するものの、完全に排除するわけではない
- 準備なしで反復型手法を用いた場合、欠陥が紛れ込むと時を置かず検出できるため、検出コストは相対的に削減できる。しかし、サイクルのテスト段階で再設計、修正、再テストをするため、修正コストは必要以上に高くつく。
- 反復型プロジェクトはコストをプロジェクト全体のあちこちで清算し、最後に集中させないのでそれほど高い感じがしない。
- 反復型でも逐次型でも準備に重点を置けばコストを削減できる。
- 100%の準備は現実的でなく、ほとんどのプロジェクトでは最も重要な要求とアーキテクチャの要素早期に洗い出すことに価値を見出す。
- 要求の 80%を事前に指定し追加の余地を残した計画を立てるか、要求の最重要な 20% を指定し、開発しながら要求や設計を追加していく。

準備がどの程度まで完了しているのかを理解し、それに応じて方法を調整することが大事だ。

#### 3.2.2 反復型か、逐次型か

ソフトウェアの種類、プロジェクトの形式、技術的な環境、スタッフのスキル、プロジェクトのビジネス目標によって異なる。

##### 逐次型がよい場合

- 要求がかなり安定している
- 設計が比較的単純で、かなり理解されている
- 開発チームがそのアプリケーション分野に精通している
- プロジェクトのリスクが低い
- 長期的な予測が重要である
- 要求、設計、コードを下流で変更すると、高くつく可能性がある

##### 反復型がよい場合

- 要求が十分に理解されていない、要求が変化しやすいことが予想される
- 設計が複雑である、手間がかかる、あるいはその両方である
- 開発チームがそのアプリケーション分野をよく知らない
- プロジェクトのリスクが低い
- 長期的な予測は重要ではない
- 要求、設計、コードを下流で変更しても、安価な可能性がある

コンストラクションの準備を最終的に左右するのは、そのコンストラクションに適した準備とは何かを判断することだ。一切準備をしなければ高い確率で変更が発生し、時間をかけすぎれば無駄な時間になる。

### 3.3 準備：課題定義

最初の準備はシステムが解決すべき課題を明記することだ（課題定義と呼ぶ）。あくまで解決すべき課題であり、ソリューションではない。また、課題意義はユーザの言葉で語られるべきであり、ユーザーの立場で説明されるべきである。コンピュータプログラムが常に最良のソリューションであるとは限らない。

### 3.4 準備：要求

要求はシステムが何をすべきか詳述したもので、ソリューションへの第一歩である。

#### 3.4.1 公式な要求が必要な理由

明確な要求は、システムの機能をプログラマではなくユーザー主導で決定するために役立つ。  
明確な要求がもたらすもの

- ユーザーが何を求めているか考えずに済む
- プログラミングの前にシステムのスコープが決定され、議論を減らす
- システムの途中変更を最小限に抑える

明確でない要求がもたらすもの

- プログラマが要求を決めながら開発する羽目になる
- 要求のエラーが見つかった場合、要求の再定義から開発済みのコードに合わせて再設計、一部の実装やテストを捨てなければならない
- 新しいエラーが紛れ込んでいないか確かめるために影響を受けないコードまで再テストが必要になる

#### 3.4.2 要求は不変という神話

プログラマがプロジェクトに長く従事するにつれて理解度を深めるように、顧客もプロジェクトとのかかわりが長くなるほど、その内容を深く理解するようになり、その結果、顧客は自分の本当のニーズに気づく。これが変更が発生する主な原因である。

#### 3.4.3 コンストラクション時の要求変更への対処

- 要求のチェックリストを使って要求の品質を評価する
- 要求の変更に伴うコストを全員に認識させる
- 変更管理手順を決める
- 変更に対応できる開発手法を使用する
- プロジェクトを中止する
- プロジェクトの業務要求の視点を忘れない

### 3.5 準備：アーキテクチャ

ソフトウェアの上位レベルの設計であり、詳細設計を支える枠組み。アーキテクチャと上位レベルの設計は区別されることがある。その場合、アーキテクチャはシステム全体に適用される設計上の制約をさし、上位レベルの設計はサブシステムや複数のクラスレベル適用される設計上の制約をさす。

#### 3.5.1 一般的なアーキテクチャの構成要素

##### プログラムの構成

まずはシステムの全体像を説明する概要が必要である。最終的な構成がけてちされるまでに検討された代案の痕跡と、その中から最終的な構成が選択された理由が、アーキテクチャから読み取れなければならない。設計の根拠は設計自体と同じくらい保守にとって重要である。

アーキテクチャはプログラムの主な構成単位を定義する。各構成単位はクラスか、ユーザーとのやり取り、WEB ページの表示、コマンドの解釈、業務ルールのカプセル化、データアクセスといった高度な機能を実現するクラスやルーチンを集めたものである。

各構成の役割は明学に定義する。構成単位の役割は一つに絞り、コカの構成単位が受け持つ領域については、できるだけ知らずに済むようにする。設計に関する情報を一つの構成単位に封じ込める。

構成単位間のやり取りの規則は明確に定義する。アーキテクチャは各構成単位が直接使用できるほかの構成単位、間接的に使用できる構成単位、絶対にしようすべきでない構成単位を説明するものでなければならない。

##### 主要なクラス

アーキテクチャは主に使用するクラスを規定すべきである。そのクラスと他のクラスがやり取りする方法を特定する。クラスの階層、状態の千二、オブジェクトの永続性についても盛り込む。

ほかに検討されていたクラスの設計を説明し、最終的な構成が選択された理由を説明できるものにする。すべてではなく、システムのふるまいの 80% を実現する 20% のクラスが明記されていればよい。

##### データ設計

使用する主なファイルやテーブル設計を説明できるものにする。ほかに検討されていたデータ構造を説明し、最終的な選択が正当であったことを説明する。こうした情報は、コンストラクションの際にアーキテクトの考えを理化するのに役立つし、保守作業の際にもかけがえのないヒントになる。

データアクセスについては、1 つのサブシステムまたはクラスからの直接アクセスに限定すべきである（秘密の隠ぺいで詳しく説明する）。
データベースを使用する場合は、アーキテクチャにデータベースの大まかな構造と内容を明記すること。複数のデータベースよりも単一のデータベースのほうが望ましい理由やフラットファイルよりもデータベースのほうが望ましい理由、同じデータにアクセスするほかのプログラムとの間のやり取り、データに基づいて作成されるビューなどを説明する必要がある。

##### 業務ルール

アーキテクチャが特定の業務ルールに依存する場合は、それらを明記し、業務ルールがシステムの設計に及ぼす影響について説明すること。例えば、顧客情報が 30 秒以上古くなってはならない、など。顧客の情報を細心に保ち、同期させる方法に、業務ルールがどのような影響を及ぼすかを説明する。

##### ユーザーインターフェイスの設計

ユーザーインターフェイスは要求の策定時に規定されることが多いが、そうでなければ、ソフトウェアアーキテクチャに明記するべきである。WEB ページのフォーマット、GUI、コマンドラインインターフェイスなど、主な要素を明記する。

新しいユーザーインターフェイスに置き換えても業務ルールやプログラムの出力部分に影響を与えないように、アーキテクチャはモジュール化する。

##### リソース管理

データベース接続、スレッド、ハンドルなど希少なリソースを管理するための計画について説明すべきである。アーキテクチャは、通常のケースと極端なケースにおいて、リソースがどれくらい消費されるか予測しなければならない。単純なケースでは必要となるリソースが十分にあることを示し、複雑なケースでは、アプリケーションが独自のリソースをより積極的に管理する必要があるため、システムのほかの部分と同じように慎重に設計しなければならない。

> 予測ってどうやるんだ。できるならやりたいが、枯渇がちになってからチューニングで大体間に合わせているし、枯渇＝損失な環境でもない限り、そっちのほうが分析の無駄がないまである。

##### セキュリティ

設計レベルとコードレベルのセキュリティ対策について説明すべきである。脅威モデルがまだ構築されていない場合は、アーキテクチャの作成時に構築しなければならない。バッファの処理、信頼できないデータ、を処理する規則、暗号化、エラーメッセージに盛り込む詳細レベル、メモリ内の機密データ保護など。

##### パフォーマンス

パフォーマンスが懸念される場合は、パフォーマンス目標を要求に明記すること。パフォーマンス目標には、リソースの使用を盛り込んでもよい。アーキテクチャは、パフォーマンス目標の推定値と、その達成が可能であると考えられる理由を説明すべきである。目標を達成できない可能性がある領域ではその理由を明記する。目標達成のためにアルゴリズムやデータ型を使用しなければならない領域があればそれも明記する。

##### スケーラビリティ

ユーザーの数、サーバーの数、ネットワークノードの数、データベースのレコード数とレコードサイズ、トランザクション量などの増加に対して、システムがどのように対処するのかを説明する。拡張が見込まれず、重視されない場合はその考えを明記すること。

##### 相互運用性

データやリソースをほかのソフトウェアやハードウェアと共有する可能性がある場合、アーキテクチャはそれをどのようにして実現するのかを説明するべきである。

##### 国際化と地域化

「国際化（internationalization）」の最初と最後と全体の 18 文字をとって、i18n という。「地域化（localization）」は同様に l18n という。プログラムを商用目的で使用する場合は、一般的な文字列や文字セットが考慮されていることをアーキテクチャに明記すべきである。文字セット、文字列の種類、翻訳クラスを用意してインターフェイスを参照する、文字列をリソースファイルに格納するなど、選択した方法とその理由を説明すること。

##### 入出力

読み取り方式として前方参照、後方参照、ジャストインタイムのいずれかを明記する。I/O エラーを検出するレベル（フィールドレベル、レコードレベル、ストリームレベル、ファイルレベル）についても説明する。

##### エラー処理

現代のコンピュータサイエンスにおいて最も厄介な問題の一つ。エラーを一貫して処理するための戦略をアーキテクチャに明記する。エラー処理はコーディング規約として扱われるがアーキテクチャレベルで扱うのが最も良い。

- エラー処理では修正するのか、修正するのか、何事もなかったように処理を続けるのか中止するのか、いずれにせよエラーの検出をユーザーに通知する。
- エラー検出を能動的に行うか、受動的に行うか。能動的に検出する場合は、ユーザー入力の検証などでエラーに先手を打つことができる。受動的に検出する場合は桁あふれなど回避できないエラーのみに対応してもよい。この選択もユーザーインターフェイスにかかわってくる。
- エラーをどのように伝達するか、エラーの原因となったデータを直ちに破棄する、エラー処理状態へ移行する、すべての処理が完了した後にユーザーに（どこかで）エラーが検出されたことを知らせる。
- エラーメッセージを処理するためのメッセージ規約。アーキテクチャレベルで一貫した戦略がないとユーザーインターフェイスがプログラムのあちこちで食い違ってしまう。
- 例外をどのように処理するか。コードがどのような状況で例外をスローするのか、どこでキャッチされるのか、どのようにログに記載されるのか、どのように文書化されるのかを明記する。
- プログラムのどのレベルでエラーを処理するのか。検出した時点で処理する、エラー処理クラスに渡す、呼び出し階層をさかのぼる、など。
- 入力データをどの程度検証するか。クラスが扱うデータの検証はどのクラスで行うのか、データ検証専門のクラスがあるのか、どのレベルのクラスも、受け取ったデータがクリーンであると想定していいのか。
- 実行環境に組み込まれている例外処理メカニズムを使用するのか、独自に構築するのか、用意されたメカニズムが各自の要求に最善の選択とは限らない。

##### フォールトトレランス
