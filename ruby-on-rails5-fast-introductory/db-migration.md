# マイグレーション

マイグレーションについて注意しなければならないことをまとめる。

## ロールバック可能であること

ロールバックはとても重要な機能である。もしもの時の復帰ばかりではなく、日常的にこの機能が必要になる可能性もある。  
例えば、DB に変更を伴う機能の開発が複数並行して走っている場合、ブランチを切り替えるたびにロールバック、再マイグレートが必要になるだろう。

`change`はバージョンアップ、ダウンの両方に使われるが、適切に書かないとダウンに失敗する

```ruby
class ChangeFreeShipDeaultToTrue < ActiveRecord::Migration[5.2]
  def chagne
    change_column_default :orders, :free_ship, true # ロールバックでエラーが発生する
  end
end
```

`change_column_default`メソッドのロールバックは`from`が必要になる

```ruby
class ChangeFreeShipDeaultToTrue < ActiveRecord::Migration[5.2]
  def chagne
    change_column_default :orders, :free_ship, from: false, to: true # ロールバック可能
  end
end
```

適切な記述をしなければロールバックできなくなる可能性がある。  
ロールバック可能かどうかは常に注意しておく必要がある。

### redo を習慣にして必ずロールバック可能性をチェックする

`bin/rails db:migrate:redo`は、バージョンダウン → バージョンアップを 1 発で行うコマンド。  
新しいマイグレーションを追加したら最新の状態に`migrate`した上で、さらに`redo`で動作チェックをすれば確実である。

### ロールバック不可能な変更で、代替策を用意しておく

カラム削除などの不可逆な変更であってもロールバックができなければ、その変更より前の状態に戻れなくなってしまうため、完全な形でなくとも対応できる必要がある。  
例えばカラム削除の変更をロールバックする場合は以下の方針が考えられる。

1. 削除されたカラムを再度追加するが、データの復旧は行わない。  
   カラムさえあれば値がなくとも問題ない場合。

1. カラムを復活させたうえで、仮の値を入れておく。
   値が必要だが厳密に同じ値である必要がない場合。
1. ロールバックを禁止する。
   `ActiveRecord::IrreversibleMigration`を`raise`する。ロールバックによってシステムが壊れることを防止する場合。ロールバックをあきらめることになる。
1. 何もせずにロールバックしたふりをする
   バージョンを上げる処理だけ記述し、バージョンを下げる処理を記述しない方法。必ずコメントでロールバックを記述していない理由を記述し、のちの混乱を回避すること。

### 過去のマイグレーションを変更しない

複数人で開発していると、過去のマイグレーションの変更は大きなリスクを伴う。デフォルト値の付け忘れなどの修正を行ってプッシュした場合、ただそれだけの変更で開発者全員の DB を一致させるために少なくないコストを支払うことになるかもしれない。  
過去のマイグレーションを変更せずに、新しいマイグレーションを積み上げて対応することを基本とした方がよい。

#### きれいなマイグレーションを追求しない

マイグレーションは DB 変更の歴史であり、時系列順に積みあがる。結果、様々のテーブル定義が複数ファイルに分割され、あるいはまじりあって混とんとした積層に見えるかもしれないが、可逆な DB の変更の歴史として正しい姿である。  
整然としたマイグレーションファイルにこだわり歴史に手を入れることはマイグレーションの機能を否定し、無効化してしまうことなのでやめること。歴史が嫌いできれいなものが好きなら`ridgepole`を導入したほうがよい。積みあがりすぎた歴史が気になるなら、ある程度の範囲を`squasher`でまとめてしまってもよい。

## 直接 DB を変更したら忘れずにマイグレーションも追加する。

常に一貫性を持たせておかないと、本番と開発環境の DB に食い違いが生まれていることに気づかないかもしれない。  
緊急時に直接 DB を変更した場合は必ずマイグレーションにも同じ変更を追加すること。直接 DB を触る必要がないように、マイグレーションの変更を即反映できる CI/CD 環境を作ることも大事だ。

## マイグレーション中でデータメンテナンスを行う場合

DB に変更を加えながら既存データに変更を加えたい場合がある。たとえば、EC サイトで配送料無料をやめるが、既存の注文は無料配送したい場合

```ruby
class AddFreeShippingToOrders < ActiveRecord::Migration[5.2]
  def up
    add_column :orders, :free_shiping, :boolean, null: false, default: false

    Order.all.each do |order|
      order.update(free_shipping: true)
    end
  end

  def down
    remove_column :orders, :free_shipping
  end
end
```

だが、このコードにはいくつか問題がある。  
まず、`order.update`は ActiveRecord の機能である。これはバリデーションを実行する。現在の`Order`モデルで正しく動いても、今後も問題なく動く保証はない。さらに、`Order`モデル自体が今後廃止、削除されない保証はない。  
次に、`all`メソッドで全件取得しているため、`Order`インスタンスが大量に生成される。データ件数が多くなればメモリが枯渇して動作が不安定になるかもしれない。
最後に、更新に失敗した場合にそれを検知できていない。失敗してもロールバックが起きないので、正しくマイグレーションが完了しないにもかかわらず正常終了してしまう

```ruby
class AddFreeShippingToOrders < ActiveRecord::Migration[5.2]
  class Order < ActiveRecord::Base;end

  def up
    add_column :orders, :free_shiping, :boolean, null: false, default: false

    Order.find_each do |order|
      order.update!(free_shipping: true)
    end
  end

  def down
    remove_column :orders, :free_shipping
  end
end
```

名前空間を汚染しないようにインナークラスで`Order`クラスを定義することでアプリケーションコードからマイグレーションを切り離した。また、`ActiveRecord`クラスの変更を想定して、`ActieRecord::Base`を継承して隔離を完全なものにしている。  
そして、`find_each`を使い、あらかじめ設定した件数だけ取得して更新し、すべて処理が完了したらさらに追加で取得することを繰り返すようにする。
また、`update!`メソッドを使うことで失敗時に例外をスローするように変更した。今回のケースならば`find_each`を使わずに`update_all`を使ってもよい。

## スキーマキャッシュの存在を意識する

マイグレーションは高速化のためスキーマをキャッシュしている。

- モデルのインスタンス作成時にスキーマをキャッシュする
- テーブル単位でキャッシュされ、同一コネクションで利用する
- テーブルへの変更はスキーマキャッシュに反映されない。手動で更新する必要がある

この性質を理解していないと以下の場合に問題が起きる。

1. migrate1：`Order.all.update!`でカラムに更新を加える
1. migrate2: `Order`に`new_column`というデフォルト値付きカラムを追加し、`Order.all.update!`で`new_column`の値を別の値に更新する

この場合、1 の時点でスキーマがキャッシュされ、2 の`update!`ではキャッシュに存在しない値を更新する状態になる。こうなってしまうと、`new_column`の値はデフォルト値のまま更新されず、エラーも発生しない。  
これを回避するためにスキーマを手動で更新する。

```ruby
# migrate2

Order.reset_column_information # スキーマキャッシュを更新
Order.find_each do |order|
  order.update!(new_column: false)
end
```

マイグレーションで ActiveRecord を使う際は、かならずスキーマキャッシュを更新すること。  
また、稼働中のアプリケーションもスキーマキャッシュを持っているため、スキーマを変更した後は再起動をかける必要がある。
サーバーの停止時間をなるべく作りたくない場合は、あらかじめ削除予定のカラムを ActiveRecord から認識されない状態にしておくこともできる。

```
class Product < ApplicationRecord
  self.ignoraed_columns = %w(image_url)
end
```
